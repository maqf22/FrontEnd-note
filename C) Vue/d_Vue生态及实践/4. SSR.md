# 一、理论

## 1. SSR

![[Pasted image 20220922155133.png]]

1. 用户请求网页
2. 服务端创建包含数据的Html文件并返回给客户端
3. 客户浏览器能免快速地解析和渲染Html文件，但此时页面不能够被富交互
4. 浏览器下载js资源
5. 此时用户只可以对符合html标准的标签进行操作，如\<a>标签或者页面滚动操作
6. 浏览器开始执行js
7. 用户可以开始随意地操作页面

## 2. CSR

![[Pasted image 20220922155755.png]]

1. 用户请求网页
2. 由CDN返回已创建好的静态Html文件给客户端
3. 客户端浏览器接收到静态Html文件，然后开始请求相应css、js文件，页面为空不可用
4. 浏览器下载js资源
5. 浏览器执行js，开始调用接口，请求数据，页面处于被占位符填充状态（Loading）
6. 由服务器restful接口返回数据
7. 浏览器获取数据，开始渲染页面在结束渲染后，取消Loading。用户可以开始交互页面。

## 3. Rendering

### SSR
- 更好的SEO：由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；
- 更快的内容到达时间（time-to-content）：特别是对于缓慢的网络情况或运行缓慢的设备；
- 每次页面跳转都需要重新加载中，体验不佳。

### CSR
- 随着单页应用（SPA）的流行而流行，比较适合不强调SEO的中后富交互应用；
- 首次页面加载要等到资源都加载执行完，用户才可以进行操作；
- 单页应用页面跳转无刷新，用户体验丝滑。

## 4. 同构

![[Pasted image 20220922160932.png]]

1. 用户请求网页
2. 服务端创建包含数据的Html文件并返回给客户端
3. 客户端浏览器能够快速地解析和渲染Html文件，但此时页面不能够被富交互
4. 浏览器下载js资源
5. 浏览器解析执行js客户端Vue开始执行客户端激活（client-side-hydration）
6. 从服务器获取非首屏或优先级较低的异步接口数据
7. 流程完毕，用户可以丝滑体验网站


# 二、同构实践

## 1. 通用代码

- 数据响应
	在纯客户端应用程序（client-only app）中，每个用户会在他们各自的浏览器中使用新的应用程序实例；
	将数据进行响应式的过程在服务器上是多余的，所默认情况下禁用。还可以避免将“数据”转换为“响应式对象”的性能开销。

- 生命周期钩子函数
	只有beforeCreate和created会在服务器端渲染（SSR）过程中被调用；
	避免在beforeCreate和created生命周期时产生全局副作用的代码，例如在其中使用setInterval。

- 访问特定平台
	禁止使用window或document；
	共享于服务器和客户端，但用于不同平台API的任务（task），建议使用能够兼容二者的三方库。例如，axios。

- 自定义指令
	推荐使用组件为抽象机制，并运行在“虚拟DOM层级（Virtual-DOM level）”（例如，使用渲染函数（render function））;
	如果自定义指令，不容易替换为组件，则可以在创建服务器renderer时，使用directives选项所提供“服务器端版本（server-side version）”。

![[Pasted image 20220922163226.png]]

## 2. asyncData

## 3. 缓存

- 页面级别缓存
	- 可以在node.js的路由层面进行缓存
	- 适用于页面内容基本不变的页面（运营推荐的内页）

- 组件级别缓存
	- vue-server-render内置支持组件级别的缓存，可以创建render时传入LRU cache
	- 适用于千人千面的用户推荐页面（每个用户看到的是不同界面）

## 4. Stream

- 内存效率
	- 相比较一次性加载一大块内容，stream将内容切分为小块chunks，分批在内存中处理
	- 避免高并发下，内存占用过大的状况发生

- 时间效率
	- 当处理完第一个chunk，即返回用户可视内容，能够减少用户访问页面的等待时机

![[Pasted image 20220922173541.png]]

## 5. Prerendering






